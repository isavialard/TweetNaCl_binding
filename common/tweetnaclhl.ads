
pragma SPARK_Mode;
pragma Style_Checks (Off);
with Ada.Text_IO;  use Ada.Text_IO;
with Interfaces.C; use Interfaces.C;
with Interfaces.C.Extensions;
with tweetnacl_h; use tweetnacl_h;


package tweetnaclhl is

   pragma Assertion_Policy (Pre => Check, Post => Check);

   -- 6 procedures de base pour générer des keypair et signer encrypter décrypter authentifier

   procedure crypto_box --Input a signed message m, a nonce n (should be generated by randombytes and used only for one message) and public and secret keys sk and pk (must be generated by crypto_box_keypair). Output a cipher text x.
     (c : out CipherText;
      sm : in PlainText;
      n : in Nonce;
      pk : in Key;
      sk : in Key)
   with
    Pre => c'Length=sm'Length+32 and isBoxPublicKey(pk)=0 and isBoxSecretKey(sk)=0 and isSigned(sm)=0;

   procedure crypto_box_open --Input a  cipher text c, the nonce n and public and secret keys sk and pk used to encrypt c. Output the signed message sm.

     (sm : out PlainText;
      c : in CipherText;
      n : in Nonce;
      pk : in Key;
      sk : in Key)
   with
       Pre => c'Length=sm'Length+32 and isBoxPublicKey(pk)=0 and isBoxSecretKey(sk)=0,
       Post => isSigned(sm)=0;

   procedure crypto_box_keypair (pk : out Key; sk : out Key) -- generates a public key pk and secret key sk to be used with crypto_box and crypto_box_open.
   with
      Post => isBoxPublicKey(pk)=0 and isBoxSecretKey(sk)=0;

   procedure crypto_sign --Input a message m and a secret key sk generated by crypto_sign_keypair. Output a signed message sm;
     (sm : out PlainText;
      m : in PlainText;
      k : in Key64)
   with
       Pre => sm'Length = m'Length + 64 and isSignSecretKey(k)=0,
       Post => isSigned(sm)=0;


   procedure crypto_sign_open --Input a signed message sm and a public key pk (must be generated by crypto_sign_keypair with the secret_key that was used to signed the message in the first place). Verify the signature and output the initial message m, and "error crypto_sign_open" if the signature is not right.
     (m : out PlainText;
      sm : in PlainText;
      pk : in Key)
     with
       Pre =>m'Length=sm'Length-64 and isSignPublicKey(pk)=0 and isSigned(sm)=0 ;

   procedure crypto_sign_keypair (pk : out Key; sk : out Key64) --generates the public key pk and secret key sk to be used with crypto_sign and crypto_sign_open
   with
      Post => isSignPublicKey(pk)=0 and isSignSecretKey(sk)=0;


   -- Sous blocs des 6 procedures principales

   procedure crypto_box_beforenm
     (k : out Key;
      pk : in Key;
      sk : in Key)
   with
      Pre => isBoxPublicKey(pk)=0 and isBoxSecretKey(sk)=0,
      Post => isBoxAfterKey(k)=0;


   procedure crypto_box_afternm
     (c : out CipherText;
      m : in PlainText;
      n : in Nonce;
      k : in Key)
   with
    Pre => c'Length=m'Length+32 and isBoxAfterKey(k)=0 and isSigned(m)=0;

   procedure crypto_box_open_afternm
     (m : out PlainText;
      c : in CipherText;
      n : in Nonce;
      k : in Key)
   with
       Pre => c'Length=m'Length+32 and isBoxAfterKey(k)=0,
       Post => isSigned(m)=0;

   procedure crypto_core_salsa20
     (argOut : out CoreOut;
      argIn : in CoreIn;
      k : in Key;
      sigma : in Authenticator) ;

   procedure crypto_core_hsalsa20
     (ArgOut : out CoreOut;
      argIn :in CoreIn;
      k :in Key;
      sigma :in Authenticator) ;

   procedure crypto_hashblocks
     (x : in out Key64;
      m : in PlainText) ;

   procedure crypto_hash
     (argOut : out Key64;
      m : in PlainText) ;

   procedure crypto_onetimeauth
     (argOut : out Authenticator;
      m : in  PlainText;
      k : in Key)
   with Pre => isSigned(m)=0;

   function crypto_onetimeauth_verify
     (h : in Authenticator;
      m : in PlainText;
      k : in Key) return int
    with Pre => isSigned(m)=0;

   procedure crypto_scalarmult
     (q : out Key;
      n : in Key;
      p : in Key) ;

   procedure crypto_scalarmult_base (q : out Key; n : in Key) ;

   procedure crypto_secretbox
     (c : out CipherText;
      m : in PlainText;
      n : in Nonce;
      k : in Key)
   with
       Pre => c'Length=m'Length+32 and isBoxAfterKey(k)=0 and isSigned(m)=0;

   procedure crypto_secretbox_open
     (m : out PlainText;
      c : in CipherText;
      n : in Nonce;
      k : in Key)
   with
       Pre => c'Length=m'Length+32 and isBoxAfterKey(k)=0,
       Post => isSigned(m)=0;

   procedure crypto_stream_xsalsa20
     (c : out CipherText;
      n : in Nonce;
      k : in Key)
   with
      Pre => isBoxAfterKey(k)=0;

   procedure crypto_stream_xsalsa20_xor
     (c : out CipherText;
      m : in  PlainText;
      n : in Nonce;
      k : in Key)
   with
    Pre => c'Length=m'Length and isBoxAfterKey(k)=0 and isSigned(m)=0;


   procedure crypto_stream_salsa20
     (c : out CipherText;
      n : in Nonce;
      k : in Key)
   with
      Pre => isBoxAfterKey(k)=0;


   procedure crypto_stream_salsa20_xor
     (c : out CipherText;
      m : in PlainText;
      n : in Nonce;
      k : in Key)
    with
    Pre => c'Length=m'Length and isBoxAfterKey(k)=0 and isSigned(m)=0;





   function crypto_verify_16 (x :in Authenticator; y :in Authenticator) return int;



   function crypto_verify_32 (x :in Key; y :in Key) return int;

   -- ghost functions

   function isBoxPublicKey(k :Key) return int;
   function isBoxAfterKey(k :Key) return int;
   function isBoxSecretKey(k :Key) return int;
   function isSignPublicKey(k :Key) return int;
   function isSignSecretKey(k :Key64) return int;
   function isSigned(m :Plaintext) return int;



end tweetnaclhl;
